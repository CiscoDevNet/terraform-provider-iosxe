// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	"github.com/CiscoDevNet/terraform-provider-iosxe/internal/provider/helpers"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

type FlowMonitor struct {
	Device       types.String              `tfsdk:"device"`
	Id           types.String              `tfsdk:"id"`
	DeleteMode   types.String              `tfsdk:"delete_mode"`
	FlowRecord   []FlowMonitorFlowRecord   `tfsdk:"flow_record"`
	FlowExporter []FlowMonitorFlowExporter `tfsdk:"flow_exporter"`
	FlowMonitor  []FlowMonitorFlowMonitor  `tfsdk:"flow_monitor"`
}

type FlowMonitorData struct {
	Device       types.String              `tfsdk:"device"`
	Id           types.String              `tfsdk:"id"`
	FlowRecord   []FlowMonitorFlowRecord   `tfsdk:"flow_record"`
	FlowExporter []FlowMonitorFlowExporter `tfsdk:"flow_exporter"`
	FlowMonitor  []FlowMonitorFlowMonitor  `tfsdk:"flow_monitor"`
}
type FlowMonitorFlowRecord struct {
	Name                          types.String `tfsdk:"name"`
	Description                   types.String `tfsdk:"description"`
	MatchIpv4SourceAddress        types.Bool   `tfsdk:"match_ipv4_source_address"`
	MatchIpv4DestinationAddress   types.Bool   `tfsdk:"match_ipv4_destination_address"`
	MatchIpv4Protocol             types.Bool   `tfsdk:"match_ipv4_protocol"`
	MatchIpv4Tos                  types.Bool   `tfsdk:"match_ipv4_tos"`
	MatchTransportSourcePort      types.Bool   `tfsdk:"match_transport_source_port"`
	MatchTransportDestinationPort types.Bool   `tfsdk:"match_transport_destination_port"`
	MatchInterfaceInput           types.Bool   `tfsdk:"match_interface_input"`
	MatchFlowDirection            types.Bool   `tfsdk:"match_flow_direction"`
	CollectInterfaceOutput        types.Bool   `tfsdk:"collect_interface_output"`
	CollectCounterBytesLong       types.Bool   `tfsdk:"collect_counter_bytes_long"`
	CollectCounterPacketsLong     types.Bool   `tfsdk:"collect_counter_packets_long"`
	CollectTransportTcpFlags      types.Bool   `tfsdk:"collect_transport_tcp_flags"`
	CollectTimestampAbsoluteFirst types.Bool   `tfsdk:"collect_timestamp_absolute_first"`
	CollectTimestampAbsoluteLast  types.Bool   `tfsdk:"collect_timestamp_absolute_last"`
}
type FlowMonitorFlowExporter struct {
	Name                                       types.String `tfsdk:"name"`
	Description                                types.String `tfsdk:"description"`
	DestinationDestinationChoiceIpdestIpdestIp types.String `tfsdk:"destination_destination_choice_ipdest_ipdest_ip"`
	SourceLoopback                             types.Int64  `tfsdk:"source_loopback"`
	TransportUdp                               types.Int64  `tfsdk:"transport_udp"`
	TemplateDataTimeout                        types.Int64  `tfsdk:"template_data_timeout"`
}
type FlowMonitorFlowMonitor struct {
	Name                types.String                                `tfsdk:"name"`
	Description         types.String                                `tfsdk:"description"`
	FlowMonitorExporter []FlowMonitorFlowMonitorFlowMonitorExporter `tfsdk:"flow_monitor_exporter"`
	CacheTimeoutActive  types.Int64                                 `tfsdk:"cache_timeout_active"`
	RecordType          types.String                                `tfsdk:"record_type"`
}
type FlowMonitorFlowMonitorFlowMonitorExporter struct {
	Name types.String `tfsdk:"name"`
}

func (data FlowMonitor) getPath() string {
	return "Cisco-IOS-XE-native:native/Cisco-IOS-XE-flow:flow"
}

func (data FlowMonitorData) getPath() string {
	return "Cisco-IOS-XE-native:native/Cisco-IOS-XE-flow:flow"
}

// if last path element has a key -> remove it
func (data FlowMonitor) getPathShort() string {
	path := data.getPath()
	re := regexp.MustCompile(`(.*)=[^\/]*$`)
	matches := re.FindStringSubmatch(path)
	if len(matches) <= 1 {
		return path
	}
	return matches[1]
}

func (data FlowMonitor) toBody(ctx context.Context) string {
	body := `{"` + helpers.LastElement(data.getPath()) + `":{}}`
	if len(data.FlowRecord) > 0 {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record", []interface{}{})
		for index, item := range data.FlowRecord {
			if !item.Name.IsNull() && !item.Name.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"name", item.Name.ValueString())
			}
			if !item.Description.IsNull() && !item.Description.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"description", item.Description.ValueString())
			}
			if !item.MatchIpv4SourceAddress.IsNull() && !item.MatchIpv4SourceAddress.IsUnknown() {
				if item.MatchIpv4SourceAddress.ValueBool() {
					body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"match.ipv4.source.address", map[string]string{})
				}
			}
			if !item.MatchIpv4DestinationAddress.IsNull() && !item.MatchIpv4DestinationAddress.IsUnknown() {
				if item.MatchIpv4DestinationAddress.ValueBool() {
					body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"match.ipv4.destination.address", map[string]string{})
				}
			}
			if !item.MatchIpv4Protocol.IsNull() && !item.MatchIpv4Protocol.IsUnknown() {
				if item.MatchIpv4Protocol.ValueBool() {
					body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"match.ipv4.protocol", map[string]string{})
				}
			}
			if !item.MatchIpv4Tos.IsNull() && !item.MatchIpv4Tos.IsUnknown() {
				if item.MatchIpv4Tos.ValueBool() {
					body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"match.ipv4.tos", map[string]string{})
				}
			}
			if !item.MatchTransportSourcePort.IsNull() && !item.MatchTransportSourcePort.IsUnknown() {
				if item.MatchTransportSourcePort.ValueBool() {
					body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"match.transport.source-port", map[string]string{})
				}
			}
			if !item.MatchTransportDestinationPort.IsNull() && !item.MatchTransportDestinationPort.IsUnknown() {
				if item.MatchTransportDestinationPort.ValueBool() {
					body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"match.transport.destination-port", map[string]string{})
				}
			}
			if !item.MatchInterfaceInput.IsNull() && !item.MatchInterfaceInput.IsUnknown() {
				if item.MatchInterfaceInput.ValueBool() {
					body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"match.interface.input", map[string]string{})
				}
			}
			if !item.MatchFlowDirection.IsNull() && !item.MatchFlowDirection.IsUnknown() {
				if item.MatchFlowDirection.ValueBool() {
					body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"match.flow.direction", map[string]string{})
				}
			}
			if !item.CollectInterfaceOutput.IsNull() && !item.CollectInterfaceOutput.IsUnknown() {
				if item.CollectInterfaceOutput.ValueBool() {
					body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"collect.interface.output", map[string]string{})
				}
			}
			if !item.CollectCounterBytesLong.IsNull() && !item.CollectCounterBytesLong.IsUnknown() {
				if item.CollectCounterBytesLong.ValueBool() {
					body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"collect.counter.bytes.long", map[string]string{})
				}
			}
			if !item.CollectCounterPacketsLong.IsNull() && !item.CollectCounterPacketsLong.IsUnknown() {
				if item.CollectCounterPacketsLong.ValueBool() {
					body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"collect.counter.packets.long", map[string]string{})
				}
			}
			if !item.CollectTransportTcpFlags.IsNull() && !item.CollectTransportTcpFlags.IsUnknown() {
				if item.CollectTransportTcpFlags.ValueBool() {
					body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"collect.transport.tcp.flags", map[string]string{})
				}
			}
			if !item.CollectTimestampAbsoluteFirst.IsNull() && !item.CollectTimestampAbsoluteFirst.IsUnknown() {
				if item.CollectTimestampAbsoluteFirst.ValueBool() {
					body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"collect.timestamp.absolute.first", map[string]string{})
				}
			}
			if !item.CollectTimestampAbsoluteLast.IsNull() && !item.CollectTimestampAbsoluteLast.IsUnknown() {
				if item.CollectTimestampAbsoluteLast.ValueBool() {
					body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"record"+"."+strconv.Itoa(index)+"."+"collect.timestamp.absolute.last", map[string]string{})
				}
			}
		}
	}
	if len(data.FlowExporter) > 0 {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"exporter", []interface{}{})
		for index, item := range data.FlowExporter {
			if !item.Name.IsNull() && !item.Name.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"exporter"+"."+strconv.Itoa(index)+"."+"name", item.Name.ValueString())
			}
			if !item.Description.IsNull() && !item.Description.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"exporter"+"."+strconv.Itoa(index)+"."+"description", item.Description.ValueString())
			}
			if !item.DestinationDestinationChoiceIpdestIpdestIp.IsNull() && !item.DestinationDestinationChoiceIpdestIpdestIp.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"exporter"+"."+strconv.Itoa(index)+"."+"destination.ipdest.ip", item.DestinationDestinationChoiceIpdestIpdestIp.ValueString())
			}
			if !item.SourceLoopback.IsNull() && !item.SourceLoopback.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"exporter"+"."+strconv.Itoa(index)+"."+"source.Loopback", strconv.FormatInt(item.SourceLoopback.ValueInt64(), 10))
			}
			if !item.TransportUdp.IsNull() && !item.TransportUdp.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"exporter"+"."+strconv.Itoa(index)+"."+"transport.udp", strconv.FormatInt(item.TransportUdp.ValueInt64(), 10))
			}
			if !item.TemplateDataTimeout.IsNull() && !item.TemplateDataTimeout.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"exporter"+"."+strconv.Itoa(index)+"."+"template.data.timeout", strconv.FormatInt(item.TemplateDataTimeout.ValueInt64(), 10))
			}
		}
	}
	if len(data.FlowMonitor) > 0 {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"monitor", []interface{}{})
		for index, item := range data.FlowMonitor {
			if !item.Name.IsNull() && !item.Name.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"monitor"+"."+strconv.Itoa(index)+"."+"name", item.Name.ValueString())
			}
			if !item.Description.IsNull() && !item.Description.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"monitor"+"."+strconv.Itoa(index)+"."+"description", item.Description.ValueString())
			}
			if !item.CacheTimeoutActive.IsNull() && !item.CacheTimeoutActive.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"monitor"+"."+strconv.Itoa(index)+"."+"cache.timeout.active", strconv.FormatInt(item.CacheTimeoutActive.ValueInt64(), 10))
			}
			if !item.RecordType.IsNull() && !item.RecordType.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"monitor"+"."+strconv.Itoa(index)+"."+"record.type", item.RecordType.ValueString())
			}
			if len(item.FlowMonitorExporter) > 0 {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"monitor"+"."+strconv.Itoa(index)+"."+"exporter", []interface{}{})
				for cindex, citem := range item.FlowMonitorExporter {
					if !citem.Name.IsNull() && !citem.Name.IsUnknown() {
						body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"monitor"+"."+strconv.Itoa(index)+"."+"exporter"+"."+strconv.Itoa(cindex)+"."+"name", citem.Name.ValueString())
					}
				}
			}
		}
	}
	return body
}

func (data *FlowMonitor) updateFromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	for i := range data.FlowRecord {
		keys := [...]string{"name"}
		keyValues := [...]string{data.FlowRecord[i].Name.ValueString()}

		var r gjson.Result
		res.Get(prefix + "record").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("name"); value.Exists() && !data.FlowRecord[i].Name.IsNull() {
			data.FlowRecord[i].Name = types.StringValue(value.String())
		} else {
			data.FlowRecord[i].Name = types.StringNull()
		}
		if value := r.Get("description"); value.Exists() && !data.FlowRecord[i].Description.IsNull() {
			data.FlowRecord[i].Description = types.StringValue(value.String())
		} else {
			data.FlowRecord[i].Description = types.StringNull()
		}
		if value := r.Get("match.ipv4.source.address"); !data.FlowRecord[i].MatchIpv4SourceAddress.IsNull() {
			if value.Exists() {
				data.FlowRecord[i].MatchIpv4SourceAddress = types.BoolValue(true)
			} else {
				data.FlowRecord[i].MatchIpv4SourceAddress = types.BoolValue(false)
			}
		} else {
			data.FlowRecord[i].MatchIpv4SourceAddress = types.BoolNull()
		}
		if value := r.Get("match.ipv4.destination.address"); !data.FlowRecord[i].MatchIpv4DestinationAddress.IsNull() {
			if value.Exists() {
				data.FlowRecord[i].MatchIpv4DestinationAddress = types.BoolValue(true)
			} else {
				data.FlowRecord[i].MatchIpv4DestinationAddress = types.BoolValue(false)
			}
		} else {
			data.FlowRecord[i].MatchIpv4DestinationAddress = types.BoolNull()
		}
		if value := r.Get("match.ipv4.protocol"); !data.FlowRecord[i].MatchIpv4Protocol.IsNull() {
			if value.Exists() {
				data.FlowRecord[i].MatchIpv4Protocol = types.BoolValue(true)
			} else {
				data.FlowRecord[i].MatchIpv4Protocol = types.BoolValue(false)
			}
		} else {
			data.FlowRecord[i].MatchIpv4Protocol = types.BoolNull()
		}
		if value := r.Get("match.ipv4.tos"); !data.FlowRecord[i].MatchIpv4Tos.IsNull() {
			if value.Exists() {
				data.FlowRecord[i].MatchIpv4Tos = types.BoolValue(true)
			} else {
				data.FlowRecord[i].MatchIpv4Tos = types.BoolValue(false)
			}
		} else {
			data.FlowRecord[i].MatchIpv4Tos = types.BoolNull()
		}
		if value := r.Get("match.transport.source-port"); !data.FlowRecord[i].MatchTransportSourcePort.IsNull() {
			if value.Exists() {
				data.FlowRecord[i].MatchTransportSourcePort = types.BoolValue(true)
			} else {
				data.FlowRecord[i].MatchTransportSourcePort = types.BoolValue(false)
			}
		} else {
			data.FlowRecord[i].MatchTransportSourcePort = types.BoolNull()
		}
		if value := r.Get("match.transport.destination-port"); !data.FlowRecord[i].MatchTransportDestinationPort.IsNull() {
			if value.Exists() {
				data.FlowRecord[i].MatchTransportDestinationPort = types.BoolValue(true)
			} else {
				data.FlowRecord[i].MatchTransportDestinationPort = types.BoolValue(false)
			}
		} else {
			data.FlowRecord[i].MatchTransportDestinationPort = types.BoolNull()
		}
		if value := r.Get("match.interface.input"); !data.FlowRecord[i].MatchInterfaceInput.IsNull() {
			if value.Exists() {
				data.FlowRecord[i].MatchInterfaceInput = types.BoolValue(true)
			} else {
				data.FlowRecord[i].MatchInterfaceInput = types.BoolValue(false)
			}
		} else {
			data.FlowRecord[i].MatchInterfaceInput = types.BoolNull()
		}
		if value := r.Get("match.flow.direction"); !data.FlowRecord[i].MatchFlowDirection.IsNull() {
			if value.Exists() {
				data.FlowRecord[i].MatchFlowDirection = types.BoolValue(true)
			} else {
				data.FlowRecord[i].MatchFlowDirection = types.BoolValue(false)
			}
		} else {
			data.FlowRecord[i].MatchFlowDirection = types.BoolNull()
		}
		if value := r.Get("collect.interface.output"); !data.FlowRecord[i].CollectInterfaceOutput.IsNull() {
			if value.Exists() {
				data.FlowRecord[i].CollectInterfaceOutput = types.BoolValue(true)
			} else {
				data.FlowRecord[i].CollectInterfaceOutput = types.BoolValue(false)
			}
		} else {
			data.FlowRecord[i].CollectInterfaceOutput = types.BoolNull()
		}
		if value := r.Get("collect.counter.bytes.long"); !data.FlowRecord[i].CollectCounterBytesLong.IsNull() {
			if value.Exists() {
				data.FlowRecord[i].CollectCounterBytesLong = types.BoolValue(true)
			} else {
				data.FlowRecord[i].CollectCounterBytesLong = types.BoolValue(false)
			}
		} else {
			data.FlowRecord[i].CollectCounterBytesLong = types.BoolNull()
		}
		if value := r.Get("collect.counter.packets.long"); !data.FlowRecord[i].CollectCounterPacketsLong.IsNull() {
			if value.Exists() {
				data.FlowRecord[i].CollectCounterPacketsLong = types.BoolValue(true)
			} else {
				data.FlowRecord[i].CollectCounterPacketsLong = types.BoolValue(false)
			}
		} else {
			data.FlowRecord[i].CollectCounterPacketsLong = types.BoolNull()
		}
		if value := r.Get("collect.transport.tcp.flags"); !data.FlowRecord[i].CollectTransportTcpFlags.IsNull() {
			if value.Exists() {
				data.FlowRecord[i].CollectTransportTcpFlags = types.BoolValue(true)
			} else {
				data.FlowRecord[i].CollectTransportTcpFlags = types.BoolValue(false)
			}
		} else {
			data.FlowRecord[i].CollectTransportTcpFlags = types.BoolNull()
		}
		if value := r.Get("collect.timestamp.absolute.first"); !data.FlowRecord[i].CollectTimestampAbsoluteFirst.IsNull() {
			if value.Exists() {
				data.FlowRecord[i].CollectTimestampAbsoluteFirst = types.BoolValue(true)
			} else {
				data.FlowRecord[i].CollectTimestampAbsoluteFirst = types.BoolValue(false)
			}
		} else {
			data.FlowRecord[i].CollectTimestampAbsoluteFirst = types.BoolNull()
		}
		if value := r.Get("collect.timestamp.absolute.last"); !data.FlowRecord[i].CollectTimestampAbsoluteLast.IsNull() {
			if value.Exists() {
				data.FlowRecord[i].CollectTimestampAbsoluteLast = types.BoolValue(true)
			} else {
				data.FlowRecord[i].CollectTimestampAbsoluteLast = types.BoolValue(false)
			}
		} else {
			data.FlowRecord[i].CollectTimestampAbsoluteLast = types.BoolNull()
		}
	}
	for i := range data.FlowExporter {
		keys := [...]string{"name"}
		keyValues := [...]string{data.FlowExporter[i].Name.ValueString()}

		var r gjson.Result
		res.Get(prefix + "exporter").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("name"); value.Exists() && !data.FlowExporter[i].Name.IsNull() {
			data.FlowExporter[i].Name = types.StringValue(value.String())
		} else {
			data.FlowExporter[i].Name = types.StringNull()
		}
		if value := r.Get("description"); value.Exists() && !data.FlowExporter[i].Description.IsNull() {
			data.FlowExporter[i].Description = types.StringValue(value.String())
		} else {
			data.FlowExporter[i].Description = types.StringNull()
		}
		if value := r.Get("destination.ipdest.ip"); value.Exists() && !data.FlowExporter[i].DestinationDestinationChoiceIpdestIpdestIp.IsNull() {
			data.FlowExporter[i].DestinationDestinationChoiceIpdestIpdestIp = types.StringValue(value.String())
		} else {
			data.FlowExporter[i].DestinationDestinationChoiceIpdestIpdestIp = types.StringNull()
		}
		if value := r.Get("source.Loopback"); value.Exists() && !data.FlowExporter[i].SourceLoopback.IsNull() {
			data.FlowExporter[i].SourceLoopback = types.Int64Value(value.Int())
		} else {
			data.FlowExporter[i].SourceLoopback = types.Int64Null()
		}
		if value := r.Get("transport.udp"); value.Exists() && !data.FlowExporter[i].TransportUdp.IsNull() {
			data.FlowExporter[i].TransportUdp = types.Int64Value(value.Int())
		} else {
			data.FlowExporter[i].TransportUdp = types.Int64Null()
		}
		if value := r.Get("template.data.timeout"); value.Exists() && !data.FlowExporter[i].TemplateDataTimeout.IsNull() {
			data.FlowExporter[i].TemplateDataTimeout = types.Int64Value(value.Int())
		} else {
			data.FlowExporter[i].TemplateDataTimeout = types.Int64Null()
		}
	}
	for i := range data.FlowMonitor {
		keys := [...]string{"name"}
		keyValues := [...]string{data.FlowMonitor[i].Name.ValueString()}

		var r gjson.Result
		res.Get(prefix + "monitor").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("name"); value.Exists() && !data.FlowMonitor[i].Name.IsNull() {
			data.FlowMonitor[i].Name = types.StringValue(value.String())
		} else {
			data.FlowMonitor[i].Name = types.StringNull()
		}
		if value := r.Get("description"); value.Exists() && !data.FlowMonitor[i].Description.IsNull() {
			data.FlowMonitor[i].Description = types.StringValue(value.String())
		} else {
			data.FlowMonitor[i].Description = types.StringNull()
		}
		for ci := range data.FlowMonitor[i].FlowMonitorExporter {
			keys := [...]string{"name"}
			keyValues := [...]string{data.FlowMonitor[i].FlowMonitorExporter[ci].Name.ValueString()}

			var cr gjson.Result
			r.Get("exporter").ForEach(
				func(_, v gjson.Result) bool {
					found := false
					for ik := range keys {
						if v.Get(keys[ik]).String() == keyValues[ik] {
							found = true
							continue
						}
						found = false
						break
					}
					if found {
						cr = v
						return false
					}
					return true
				},
			)
			if value := cr.Get("name"); value.Exists() && !data.FlowMonitor[i].FlowMonitorExporter[ci].Name.IsNull() {
				data.FlowMonitor[i].FlowMonitorExporter[ci].Name = types.StringValue(value.String())
			} else {
				data.FlowMonitor[i].FlowMonitorExporter[ci].Name = types.StringNull()
			}
		}
		if value := r.Get("cache.timeout.active"); value.Exists() && !data.FlowMonitor[i].CacheTimeoutActive.IsNull() {
			data.FlowMonitor[i].CacheTimeoutActive = types.Int64Value(value.Int())
		} else {
			data.FlowMonitor[i].CacheTimeoutActive = types.Int64Null()
		}
		if value := r.Get("record.type"); value.Exists() && !data.FlowMonitor[i].RecordType.IsNull() {
			data.FlowMonitor[i].RecordType = types.StringValue(value.String())
		} else {
			data.FlowMonitor[i].RecordType = types.StringNull()
		}
	}
}

func (data *FlowMonitorData) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "record"); value.Exists() {
		data.FlowRecord = make([]FlowMonitorFlowRecord, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := FlowMonitorFlowRecord{}
			if cValue := v.Get("name"); cValue.Exists() {
				item.Name = types.StringValue(cValue.String())
			}
			if cValue := v.Get("description"); cValue.Exists() {
				item.Description = types.StringValue(cValue.String())
			}
			if cValue := v.Get("match.ipv4.source.address"); cValue.Exists() {
				item.MatchIpv4SourceAddress = types.BoolValue(true)
			} else {
				item.MatchIpv4SourceAddress = types.BoolValue(false)
			}
			if cValue := v.Get("match.ipv4.destination.address"); cValue.Exists() {
				item.MatchIpv4DestinationAddress = types.BoolValue(true)
			} else {
				item.MatchIpv4DestinationAddress = types.BoolValue(false)
			}
			if cValue := v.Get("match.ipv4.protocol"); cValue.Exists() {
				item.MatchIpv4Protocol = types.BoolValue(true)
			} else {
				item.MatchIpv4Protocol = types.BoolValue(false)
			}
			if cValue := v.Get("match.ipv4.tos"); cValue.Exists() {
				item.MatchIpv4Tos = types.BoolValue(true)
			} else {
				item.MatchIpv4Tos = types.BoolValue(false)
			}
			if cValue := v.Get("match.transport.source-port"); cValue.Exists() {
				item.MatchTransportSourcePort = types.BoolValue(true)
			} else {
				item.MatchTransportSourcePort = types.BoolValue(false)
			}
			if cValue := v.Get("match.transport.destination-port"); cValue.Exists() {
				item.MatchTransportDestinationPort = types.BoolValue(true)
			} else {
				item.MatchTransportDestinationPort = types.BoolValue(false)
			}
			if cValue := v.Get("match.interface.input"); cValue.Exists() {
				item.MatchInterfaceInput = types.BoolValue(true)
			} else {
				item.MatchInterfaceInput = types.BoolValue(false)
			}
			if cValue := v.Get("match.flow.direction"); cValue.Exists() {
				item.MatchFlowDirection = types.BoolValue(true)
			} else {
				item.MatchFlowDirection = types.BoolValue(false)
			}
			if cValue := v.Get("collect.interface.output"); cValue.Exists() {
				item.CollectInterfaceOutput = types.BoolValue(true)
			} else {
				item.CollectInterfaceOutput = types.BoolValue(false)
			}
			if cValue := v.Get("collect.counter.bytes.long"); cValue.Exists() {
				item.CollectCounterBytesLong = types.BoolValue(true)
			} else {
				item.CollectCounterBytesLong = types.BoolValue(false)
			}
			if cValue := v.Get("collect.counter.packets.long"); cValue.Exists() {
				item.CollectCounterPacketsLong = types.BoolValue(true)
			} else {
				item.CollectCounterPacketsLong = types.BoolValue(false)
			}
			if cValue := v.Get("collect.transport.tcp.flags"); cValue.Exists() {
				item.CollectTransportTcpFlags = types.BoolValue(true)
			} else {
				item.CollectTransportTcpFlags = types.BoolValue(false)
			}
			if cValue := v.Get("collect.timestamp.absolute.first"); cValue.Exists() {
				item.CollectTimestampAbsoluteFirst = types.BoolValue(true)
			} else {
				item.CollectTimestampAbsoluteFirst = types.BoolValue(false)
			}
			if cValue := v.Get("collect.timestamp.absolute.last"); cValue.Exists() {
				item.CollectTimestampAbsoluteLast = types.BoolValue(true)
			} else {
				item.CollectTimestampAbsoluteLast = types.BoolValue(false)
			}
			data.FlowRecord = append(data.FlowRecord, item)
			return true
		})
	}
	if value := res.Get(prefix + "exporter"); value.Exists() {
		data.FlowExporter = make([]FlowMonitorFlowExporter, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := FlowMonitorFlowExporter{}
			if cValue := v.Get("name"); cValue.Exists() {
				item.Name = types.StringValue(cValue.String())
			}
			if cValue := v.Get("description"); cValue.Exists() {
				item.Description = types.StringValue(cValue.String())
			}
			if cValue := v.Get("destination.ipdest.ip"); cValue.Exists() {
				item.DestinationDestinationChoiceIpdestIpdestIp = types.StringValue(cValue.String())
			}
			if cValue := v.Get("source.Loopback"); cValue.Exists() {
				item.SourceLoopback = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("transport.udp"); cValue.Exists() {
				item.TransportUdp = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("template.data.timeout"); cValue.Exists() {
				item.TemplateDataTimeout = types.Int64Value(cValue.Int())
			}
			data.FlowExporter = append(data.FlowExporter, item)
			return true
		})
	}
	if value := res.Get(prefix + "monitor"); value.Exists() {
		data.FlowMonitor = make([]FlowMonitorFlowMonitor, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := FlowMonitorFlowMonitor{}
			if cValue := v.Get("name"); cValue.Exists() {
				item.Name = types.StringValue(cValue.String())
			}
			if cValue := v.Get("description"); cValue.Exists() {
				item.Description = types.StringValue(cValue.String())
			}
			if cValue := v.Get("exporter"); cValue.Exists() {
				item.FlowMonitorExporter = make([]FlowMonitorFlowMonitorFlowMonitorExporter, 0)
				cValue.ForEach(func(ck, cv gjson.Result) bool {
					cItem := FlowMonitorFlowMonitorFlowMonitorExporter{}
					if ccValue := cv.Get("name"); ccValue.Exists() {
						cItem.Name = types.StringValue(ccValue.String())
					}
					item.FlowMonitorExporter = append(item.FlowMonitorExporter, cItem)
					return true
				})
			}
			if cValue := v.Get("cache.timeout.active"); cValue.Exists() {
				item.CacheTimeoutActive = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("record.type"); cValue.Exists() {
				item.RecordType = types.StringValue(cValue.String())
			}
			data.FlowMonitor = append(data.FlowMonitor, item)
			return true
		})
	}
}

func (data *FlowMonitor) getDeletedItems(ctx context.Context, state FlowMonitor) []string {
	deletedItems := make([]string, 0)
	for i := range state.FlowRecord {
		stateKeyValues := [...]string{state.FlowRecord[i].Name.ValueString()}

		emptyKeys := true
		if !reflect.ValueOf(state.FlowRecord[i].Name.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.FlowRecord {
			found = true
			if state.FlowRecord[i].Name.ValueString() != data.FlowRecord[j].Name.ValueString() {
				found = false
			}
			if found {
				if !state.FlowRecord[i].Description.IsNull() && data.FlowRecord[j].Description.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/description", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowRecord[i].MatchIpv4SourceAddress.IsNull() && data.FlowRecord[j].MatchIpv4SourceAddress.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/match/ipv4/source/address", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowRecord[i].MatchIpv4DestinationAddress.IsNull() && data.FlowRecord[j].MatchIpv4DestinationAddress.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/match/ipv4/destination/address", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowRecord[i].MatchIpv4Protocol.IsNull() && data.FlowRecord[j].MatchIpv4Protocol.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/match/ipv4/protocol", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowRecord[i].MatchIpv4Tos.IsNull() && data.FlowRecord[j].MatchIpv4Tos.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/match/ipv4/tos", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowRecord[i].MatchTransportSourcePort.IsNull() && data.FlowRecord[j].MatchTransportSourcePort.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/match/transport/source-port", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowRecord[i].MatchTransportDestinationPort.IsNull() && data.FlowRecord[j].MatchTransportDestinationPort.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/match/transport/destination-port", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowRecord[i].MatchInterfaceInput.IsNull() && data.FlowRecord[j].MatchInterfaceInput.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/match/interface/input", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowRecord[i].MatchFlowDirection.IsNull() && data.FlowRecord[j].MatchFlowDirection.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/match/flow/direction", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowRecord[i].CollectInterfaceOutput.IsNull() && data.FlowRecord[j].CollectInterfaceOutput.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/collect/interface/output", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowRecord[i].CollectCounterBytesLong.IsNull() && data.FlowRecord[j].CollectCounterBytesLong.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/collect/counter/bytes/long", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowRecord[i].CollectCounterPacketsLong.IsNull() && data.FlowRecord[j].CollectCounterPacketsLong.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/collect/counter/packets/long", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowRecord[i].CollectTransportTcpFlags.IsNull() && data.FlowRecord[j].CollectTransportTcpFlags.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/collect/transport/tcp/flags", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowRecord[i].CollectTimestampAbsoluteFirst.IsNull() && data.FlowRecord[j].CollectTimestampAbsoluteFirst.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/collect/timestamp/absolute/first", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowRecord[i].CollectTimestampAbsoluteLast.IsNull() && data.FlowRecord[j].CollectTimestampAbsoluteLast.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v/collect/timestamp/absolute/last", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/record=%v", state.getPath(), strings.Join(stateKeyValues[:], ",")))
		}
	}
	for i := range state.FlowExporter {
		stateKeyValues := [...]string{state.FlowExporter[i].Name.ValueString()}

		emptyKeys := true
		if !reflect.ValueOf(state.FlowExporter[i].Name.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.FlowExporter {
			found = true
			if state.FlowExporter[i].Name.ValueString() != data.FlowExporter[j].Name.ValueString() {
				found = false
			}
			if found {
				if !state.FlowExporter[i].Description.IsNull() && data.FlowExporter[j].Description.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/exporter=%v/description", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowExporter[i].DestinationDestinationChoiceIpdestIpdestIp.IsNull() && data.FlowExporter[j].DestinationDestinationChoiceIpdestIpdestIp.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/exporter=%v/destination/ipdest/ip", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowExporter[i].SourceLoopback.IsNull() && data.FlowExporter[j].SourceLoopback.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/exporter=%v/source/Loopback", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowExporter[i].TransportUdp.IsNull() && data.FlowExporter[j].TransportUdp.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/exporter=%v/transport/udp", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowExporter[i].TemplateDataTimeout.IsNull() && data.FlowExporter[j].TemplateDataTimeout.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/exporter=%v/template/data/timeout", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/exporter=%v", state.getPath(), strings.Join(stateKeyValues[:], ",")))
		}
	}
	for i := range state.FlowMonitor {
		stateKeyValues := [...]string{state.FlowMonitor[i].Name.ValueString()}

		emptyKeys := true
		if !reflect.ValueOf(state.FlowMonitor[i].Name.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.FlowMonitor {
			found = true
			if state.FlowMonitor[i].Name.ValueString() != data.FlowMonitor[j].Name.ValueString() {
				found = false
			}
			if found {
				if !state.FlowMonitor[i].Description.IsNull() && data.FlowMonitor[j].Description.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/monitor=%v/description", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				for ci := range state.FlowMonitor[i].FlowMonitorExporter {
					cstateKeyValues := [...]string{state.FlowMonitor[i].FlowMonitorExporter[ci].Name.ValueString()}

					cemptyKeys := true
					if !reflect.ValueOf(state.FlowMonitor[i].FlowMonitorExporter[ci].Name.ValueString()).IsZero() {
						cemptyKeys = false
					}
					if cemptyKeys {
						continue
					}

					found := false
					for cj := range data.FlowMonitor[j].FlowMonitorExporter {
						found = true
						if state.FlowMonitor[i].FlowMonitorExporter[ci].Name.ValueString() != data.FlowMonitor[j].FlowMonitorExporter[cj].Name.ValueString() {
							found = false
						}
						if found {
							break
						}
					}
					if !found {
						deletedItems = append(deletedItems, fmt.Sprintf("%v/monitor=%v/exporter=%v", state.getPath(), strings.Join(stateKeyValues[:], ","), strings.Join(cstateKeyValues[:], ",")))
					}
				}
				if !state.FlowMonitor[i].CacheTimeoutActive.IsNull() && data.FlowMonitor[j].CacheTimeoutActive.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/monitor=%v/cache/timeout/active", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.FlowMonitor[i].RecordType.IsNull() && data.FlowMonitor[j].RecordType.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/monitor=%v/record/type", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/monitor=%v", state.getPath(), strings.Join(stateKeyValues[:], ",")))
		}
	}
	return deletedItems
}

func (data *FlowMonitor) getEmptyLeafsDelete(ctx context.Context) []string {
	emptyLeafsDelete := make([]string, 0)

	for i := range data.FlowRecord {
		keyValues := [...]string{data.FlowRecord[i].Name.ValueString()}
		if !data.FlowRecord[i].MatchIpv4SourceAddress.IsNull() && !data.FlowRecord[i].MatchIpv4SourceAddress.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record=%v/match/ipv4/source/address", data.getPath(), strings.Join(keyValues[:], ",")))
		}
		if !data.FlowRecord[i].MatchIpv4DestinationAddress.IsNull() && !data.FlowRecord[i].MatchIpv4DestinationAddress.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record=%v/match/ipv4/destination/address", data.getPath(), strings.Join(keyValues[:], ",")))
		}
		if !data.FlowRecord[i].MatchIpv4Protocol.IsNull() && !data.FlowRecord[i].MatchIpv4Protocol.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record=%v/match/ipv4/protocol", data.getPath(), strings.Join(keyValues[:], ",")))
		}
		if !data.FlowRecord[i].MatchIpv4Tos.IsNull() && !data.FlowRecord[i].MatchIpv4Tos.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record=%v/match/ipv4/tos", data.getPath(), strings.Join(keyValues[:], ",")))
		}
		if !data.FlowRecord[i].MatchTransportSourcePort.IsNull() && !data.FlowRecord[i].MatchTransportSourcePort.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record=%v/match/transport/source-port", data.getPath(), strings.Join(keyValues[:], ",")))
		}
		if !data.FlowRecord[i].MatchTransportDestinationPort.IsNull() && !data.FlowRecord[i].MatchTransportDestinationPort.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record=%v/match/transport/destination-port", data.getPath(), strings.Join(keyValues[:], ",")))
		}
		if !data.FlowRecord[i].MatchInterfaceInput.IsNull() && !data.FlowRecord[i].MatchInterfaceInput.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record=%v/match/interface/input", data.getPath(), strings.Join(keyValues[:], ",")))
		}
		if !data.FlowRecord[i].MatchFlowDirection.IsNull() && !data.FlowRecord[i].MatchFlowDirection.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record=%v/match/flow/direction", data.getPath(), strings.Join(keyValues[:], ",")))
		}
		if !data.FlowRecord[i].CollectInterfaceOutput.IsNull() && !data.FlowRecord[i].CollectInterfaceOutput.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record=%v/collect/interface/output", data.getPath(), strings.Join(keyValues[:], ",")))
		}
		if !data.FlowRecord[i].CollectCounterBytesLong.IsNull() && !data.FlowRecord[i].CollectCounterBytesLong.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record=%v/collect/counter/bytes/long", data.getPath(), strings.Join(keyValues[:], ",")))
		}
		if !data.FlowRecord[i].CollectCounterPacketsLong.IsNull() && !data.FlowRecord[i].CollectCounterPacketsLong.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record=%v/collect/counter/packets/long", data.getPath(), strings.Join(keyValues[:], ",")))
		}
		if !data.FlowRecord[i].CollectTransportTcpFlags.IsNull() && !data.FlowRecord[i].CollectTransportTcpFlags.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record=%v/collect/transport/tcp/flags", data.getPath(), strings.Join(keyValues[:], ",")))
		}
		if !data.FlowRecord[i].CollectTimestampAbsoluteFirst.IsNull() && !data.FlowRecord[i].CollectTimestampAbsoluteFirst.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record=%v/collect/timestamp/absolute/first", data.getPath(), strings.Join(keyValues[:], ",")))
		}
		if !data.FlowRecord[i].CollectTimestampAbsoluteLast.IsNull() && !data.FlowRecord[i].CollectTimestampAbsoluteLast.ValueBool() {
			emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/record=%v/collect/timestamp/absolute/last", data.getPath(), strings.Join(keyValues[:], ",")))
		}
	}

	return emptyLeafsDelete
}

func (data *FlowMonitor) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	for i := range data.FlowRecord {
		keyValues := [...]string{data.FlowRecord[i].Name.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/record=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.FlowExporter {
		keyValues := [...]string{data.FlowExporter[i].Name.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/exporter=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.FlowMonitor {
		keyValues := [...]string{data.FlowMonitor[i].Name.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/monitor=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	return deletePaths
}
