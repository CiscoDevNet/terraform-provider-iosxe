// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin imports
import (
	"context"
	"fmt"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	"github.com/CiscoDevNet/terraform-provider-iosxe/internal/provider/helpers"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// End of section. //template:end imports

// Section below is generated&owned by "gen/generator.go". //template:begin types
type CTS struct {
	Device                              types.String                   `tfsdk:"device"`
	Id                                  types.String                   `tfsdk:"id"`
	DeleteMode                          types.String                   `tfsdk:"delete_mode"`
	AuthorizationList                   types.String                   `tfsdk:"authorization_list"`
	Sgt                                 types.Int64                    `tfsdk:"sgt"`
	SxpEnable                           types.Bool                     `tfsdk:"sxp_enable"`
	SxpDefaultPasswordType              types.String                   `tfsdk:"sxp_default_password_type"`
	SxpDefaultPassword                  types.String                   `tfsdk:"sxp_default_password"`
	SxpRetryPeriod                      types.Int64                    `tfsdk:"sxp_retry_period"`
	SxpConnectionPeersIpv4              []CTSSxpConnectionPeersIpv4    `tfsdk:"sxp_connection_peers_ipv4"`
	SxpConnectionPeersIpv4Vrf           []CTSSxpConnectionPeersIpv4Vrf `tfsdk:"sxp_connection_peers_ipv4_vrf"`
	SxpSpeakerHoldTime                  types.Int64                    `tfsdk:"sxp_speaker_hold_time"`
	SxpListenerHoldMinTime              types.Int64                    `tfsdk:"sxp_listener_hold_min_time"`
	SxpListenerHoldMaxTime              types.Int64                    `tfsdk:"sxp_listener_hold_max_time"`
	RoleBasedEnforcement                types.Bool                     `tfsdk:"role_based_enforcement"`
	RoleBasedEnforcementLoggingInterval types.Int64                    `tfsdk:"role_based_enforcement_logging_interval"`
	RoleBasedEnforcementVlanLists       types.List                     `tfsdk:"role_based_enforcement_vlan_lists"`
	RoleBasedPermissionsDefaultAclName  types.List                     `tfsdk:"role_based_permissions_default_acl_name"`
}

type CTSData struct {
	Device                              types.String                   `tfsdk:"device"`
	Id                                  types.String                   `tfsdk:"id"`
	AuthorizationList                   types.String                   `tfsdk:"authorization_list"`
	Sgt                                 types.Int64                    `tfsdk:"sgt"`
	SxpEnable                           types.Bool                     `tfsdk:"sxp_enable"`
	SxpDefaultPasswordType              types.String                   `tfsdk:"sxp_default_password_type"`
	SxpDefaultPassword                  types.String                   `tfsdk:"sxp_default_password"`
	SxpRetryPeriod                      types.Int64                    `tfsdk:"sxp_retry_period"`
	SxpConnectionPeersIpv4              []CTSSxpConnectionPeersIpv4    `tfsdk:"sxp_connection_peers_ipv4"`
	SxpConnectionPeersIpv4Vrf           []CTSSxpConnectionPeersIpv4Vrf `tfsdk:"sxp_connection_peers_ipv4_vrf"`
	SxpSpeakerHoldTime                  types.Int64                    `tfsdk:"sxp_speaker_hold_time"`
	SxpListenerHoldMinTime              types.Int64                    `tfsdk:"sxp_listener_hold_min_time"`
	SxpListenerHoldMaxTime              types.Int64                    `tfsdk:"sxp_listener_hold_max_time"`
	RoleBasedEnforcement                types.Bool                     `tfsdk:"role_based_enforcement"`
	RoleBasedEnforcementLoggingInterval types.Int64                    `tfsdk:"role_based_enforcement_logging_interval"`
	RoleBasedEnforcementVlanLists       types.List                     `tfsdk:"role_based_enforcement_vlan_lists"`
	RoleBasedPermissionsDefaultAclName  types.List                     `tfsdk:"role_based_permissions_default_acl_name"`
}
type CTSSxpConnectionPeersIpv4 struct {
	Ip             types.String `tfsdk:"ip"`
	SourceIp       types.String `tfsdk:"source_ip"`
	Password       types.String `tfsdk:"password"`
	ConnectionMode types.String `tfsdk:"connection_mode"`
	Option         types.String `tfsdk:"option"`
	HoldTime       types.Int64  `tfsdk:"hold_time"`
	MaxTime        types.Int64  `tfsdk:"max_time"`
}
type CTSSxpConnectionPeersIpv4Vrf struct {
	Ip             types.String `tfsdk:"ip"`
	Vrf            types.String `tfsdk:"vrf"`
	SourceIp       types.String `tfsdk:"source_ip"`
	Password       types.String `tfsdk:"password"`
	ConnectionMode types.String `tfsdk:"connection_mode"`
	Option         types.String `tfsdk:"option"`
	HoldTime       types.Int64  `tfsdk:"hold_time"`
	MaxTime        types.Int64  `tfsdk:"max_time"`
}

// End of section. //template:end types

// Section below is generated&owned by "gen/generator.go". //template:begin getPath

func (data CTS) getPath() string {
	return "Cisco-IOS-XE-native:native/cts"
}

func (data CTSData) getPath() string {
	return "Cisco-IOS-XE-native:native/cts"
}

// if last path element has a key -> remove it
func (data CTS) getPathShort() string {
	path := data.getPath()
	re := regexp.MustCompile(`(.*)=[^\/]*$`)
	matches := re.FindStringSubmatch(path)
	if len(matches) <= 1 {
		return path
	}
	return matches[1]
}

// End of section. //template:end getPath

// Section below is generated&owned by "gen/generator.go". //template:begin toBody

func (data CTS) toBody(ctx context.Context) string {
	body := `{"` + helpers.LastElement(data.getPath()) + `":{}}`
	if !data.AuthorizationList.IsNull() && !data.AuthorizationList.IsUnknown() {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:authorization.list", data.AuthorizationList.ValueString())
	}
	if !data.Sgt.IsNull() && !data.Sgt.IsUnknown() {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sgt", strconv.FormatInt(data.Sgt.ValueInt64(), 10))
	}
	if !data.SxpEnable.IsNull() && !data.SxpEnable.IsUnknown() {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.sxp-def-enable", data.SxpEnable.ValueBool())
	}
	if !data.SxpDefaultPasswordType.IsNull() && !data.SxpDefaultPasswordType.IsUnknown() {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.default.password.type", data.SxpDefaultPasswordType.ValueString())
	}
	if !data.SxpDefaultPassword.IsNull() && !data.SxpDefaultPassword.IsUnknown() {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.default.password.secret", data.SxpDefaultPassword.ValueString())
	}
	if !data.SxpRetryPeriod.IsNull() && !data.SxpRetryPeriod.IsUnknown() {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.retry.period", strconv.FormatInt(data.SxpRetryPeriod.ValueInt64(), 10))
	}
	if !data.SxpSpeakerHoldTime.IsNull() && !data.SxpSpeakerHoldTime.IsUnknown() {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.speaker.hold-time", strconv.FormatInt(data.SxpSpeakerHoldTime.ValueInt64(), 10))
	}
	if !data.SxpListenerHoldMinTime.IsNull() && !data.SxpListenerHoldMinTime.IsUnknown() {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.listener.hold-time.min-time", strconv.FormatInt(data.SxpListenerHoldMinTime.ValueInt64(), 10))
	}
	if !data.SxpListenerHoldMaxTime.IsNull() && !data.SxpListenerHoldMaxTime.IsUnknown() {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.listener.hold-time.max-time", strconv.FormatInt(data.SxpListenerHoldMaxTime.ValueInt64(), 10))
	}
	if !data.RoleBasedEnforcement.IsNull() && !data.RoleBasedEnforcement.IsUnknown() {
		if data.RoleBasedEnforcement.ValueBool() {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:role-based.enforcement-only.enforcement", map[string]string{})
		}
	}
	if !data.RoleBasedEnforcementLoggingInterval.IsNull() && !data.RoleBasedEnforcementLoggingInterval.IsUnknown() {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:role-based.enforcement.logging-interval", strconv.FormatInt(data.RoleBasedEnforcementLoggingInterval.ValueInt64(), 10))
	}
	if !data.RoleBasedEnforcementVlanLists.IsNull() && !data.RoleBasedEnforcementVlanLists.IsUnknown() {
		var values []int
		data.RoleBasedEnforcementVlanLists.ElementsAs(ctx, &values, false)
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:role-based.enforcement.vlan-lists", values)
	}
	if !data.RoleBasedPermissionsDefaultAclName.IsNull() && !data.RoleBasedPermissionsDefaultAclName.IsUnknown() {
		var values []string
		data.RoleBasedPermissionsDefaultAclName.ElementsAs(ctx, &values, false)
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:role-based.permissions.default.ACL-name-new", values)
	}
	if len(data.SxpConnectionPeersIpv4) > 0 {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-no-vrf", []interface{}{})
		for index, item := range data.SxpConnectionPeersIpv4 {
			if !item.Ip.IsNull() && !item.Ip.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-no-vrf"+"."+strconv.Itoa(index)+"."+"ipv4", item.Ip.ValueString())
			}
			if !item.SourceIp.IsNull() && !item.SourceIp.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-no-vrf"+"."+strconv.Itoa(index)+"."+"source", item.SourceIp.ValueString())
			}
			if !item.Password.IsNull() && !item.Password.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-no-vrf"+"."+strconv.Itoa(index)+"."+"password", item.Password.ValueString())
			}
			if !item.ConnectionMode.IsNull() && !item.ConnectionMode.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-no-vrf"+"."+strconv.Itoa(index)+"."+"mode", item.ConnectionMode.ValueString())
			}
			if !item.Option.IsNull() && !item.Option.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-no-vrf"+"."+strconv.Itoa(index)+"."+"option", item.Option.ValueString())
			}
			if !item.HoldTime.IsNull() && !item.HoldTime.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-no-vrf"+"."+strconv.Itoa(index)+"."+"hold-time", strconv.FormatInt(item.HoldTime.ValueInt64(), 10))
			}
			if !item.MaxTime.IsNull() && !item.MaxTime.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-no-vrf"+"."+strconv.Itoa(index)+"."+"max-time", strconv.FormatInt(item.MaxTime.ValueInt64(), 10))
			}
		}
	}
	if len(data.SxpConnectionPeersIpv4Vrf) > 0 {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-with-vrf", []interface{}{})
		for index, item := range data.SxpConnectionPeersIpv4Vrf {
			if !item.Ip.IsNull() && !item.Ip.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-with-vrf"+"."+strconv.Itoa(index)+"."+"ipv4", item.Ip.ValueString())
			}
			if !item.Vrf.IsNull() && !item.Vrf.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-with-vrf"+"."+strconv.Itoa(index)+"."+"vrf", item.Vrf.ValueString())
			}
			if !item.SourceIp.IsNull() && !item.SourceIp.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-with-vrf"+"."+strconv.Itoa(index)+"."+"source", item.SourceIp.ValueString())
			}
			if !item.Password.IsNull() && !item.Password.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-with-vrf"+"."+strconv.Itoa(index)+"."+"password", item.Password.ValueString())
			}
			if !item.ConnectionMode.IsNull() && !item.ConnectionMode.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-with-vrf"+"."+strconv.Itoa(index)+"."+"mode", item.ConnectionMode.ValueString())
			}
			if !item.Option.IsNull() && !item.Option.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-with-vrf"+"."+strconv.Itoa(index)+"."+"option", item.Option.ValueString())
			}
			if !item.HoldTime.IsNull() && !item.HoldTime.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-with-vrf"+"."+strconv.Itoa(index)+"."+"hold-time", strconv.FormatInt(item.HoldTime.ValueInt64(), 10))
			}
			if !item.MaxTime.IsNull() && !item.MaxTime.IsUnknown() {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-with-vrf"+"."+strconv.Itoa(index)+"."+"max-time", strconv.FormatInt(item.MaxTime.ValueInt64(), 10))
			}
		}
	}
	return body
}

// End of section. //template:end toBody

// Section below is generated&owned by "gen/generator.go". //template:begin updateFromBody

func (data *CTS) updateFromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:authorization.list"); value.Exists() && !data.AuthorizationList.IsNull() {
		data.AuthorizationList = types.StringValue(value.String())
	} else {
		data.AuthorizationList = types.StringNull()
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sgt"); value.Exists() && !data.Sgt.IsNull() {
		data.Sgt = types.Int64Value(value.Int())
	} else {
		data.Sgt = types.Int64Null()
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.sxp-def-enable"); !data.SxpEnable.IsNull() {
		if value.Exists() {
			data.SxpEnable = types.BoolValue(value.Bool())
		}
	} else {
		data.SxpEnable = types.BoolNull()
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.retry.period"); value.Exists() && !data.SxpRetryPeriod.IsNull() {
		data.SxpRetryPeriod = types.Int64Value(value.Int())
	} else {
		data.SxpRetryPeriod = types.Int64Null()
	}
	for i := range data.SxpConnectionPeersIpv4 {
		keys := [...]string{"ipv4"}
		keyValues := [...]string{data.SxpConnectionPeersIpv4[i].Ip.ValueString()}

		var r gjson.Result
		res.Get(prefix + "Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-no-vrf").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("ipv4"); value.Exists() && !data.SxpConnectionPeersIpv4[i].Ip.IsNull() {
			data.SxpConnectionPeersIpv4[i].Ip = types.StringValue(value.String())
		} else {
			data.SxpConnectionPeersIpv4[i].Ip = types.StringNull()
		}
		if value := r.Get("source"); value.Exists() && !data.SxpConnectionPeersIpv4[i].SourceIp.IsNull() {
			data.SxpConnectionPeersIpv4[i].SourceIp = types.StringValue(value.String())
		} else {
			data.SxpConnectionPeersIpv4[i].SourceIp = types.StringNull()
		}
		if value := r.Get("mode"); value.Exists() && !data.SxpConnectionPeersIpv4[i].ConnectionMode.IsNull() {
			data.SxpConnectionPeersIpv4[i].ConnectionMode = types.StringValue(value.String())
		} else {
			data.SxpConnectionPeersIpv4[i].ConnectionMode = types.StringNull()
		}
		if value := r.Get("option"); value.Exists() && !data.SxpConnectionPeersIpv4[i].Option.IsNull() {
			data.SxpConnectionPeersIpv4[i].Option = types.StringValue(value.String())
		} else {
			data.SxpConnectionPeersIpv4[i].Option = types.StringNull()
		}
		if value := r.Get("hold-time"); value.Exists() && !data.SxpConnectionPeersIpv4[i].HoldTime.IsNull() {
			data.SxpConnectionPeersIpv4[i].HoldTime = types.Int64Value(value.Int())
		} else {
			data.SxpConnectionPeersIpv4[i].HoldTime = types.Int64Null()
		}
		if value := r.Get("max-time"); value.Exists() && !data.SxpConnectionPeersIpv4[i].MaxTime.IsNull() {
			data.SxpConnectionPeersIpv4[i].MaxTime = types.Int64Value(value.Int())
		} else {
			data.SxpConnectionPeersIpv4[i].MaxTime = types.Int64Null()
		}
	}
	for i := range data.SxpConnectionPeersIpv4Vrf {
		keys := [...]string{"ipv4", "vrf"}
		keyValues := [...]string{data.SxpConnectionPeersIpv4Vrf[i].Ip.ValueString(), data.SxpConnectionPeersIpv4Vrf[i].Vrf.ValueString()}

		var r gjson.Result
		res.Get(prefix + "Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-with-vrf").ForEach(
			func(_, v gjson.Result) bool {
				found := false
				for ik := range keys {
					if v.Get(keys[ik]).String() == keyValues[ik] {
						found = true
						continue
					}
					found = false
					break
				}
				if found {
					r = v
					return false
				}
				return true
			},
		)
		if value := r.Get("ipv4"); value.Exists() && !data.SxpConnectionPeersIpv4Vrf[i].Ip.IsNull() {
			data.SxpConnectionPeersIpv4Vrf[i].Ip = types.StringValue(value.String())
		} else {
			data.SxpConnectionPeersIpv4Vrf[i].Ip = types.StringNull()
		}
		if value := r.Get("vrf"); value.Exists() && !data.SxpConnectionPeersIpv4Vrf[i].Vrf.IsNull() {
			data.SxpConnectionPeersIpv4Vrf[i].Vrf = types.StringValue(value.String())
		} else {
			data.SxpConnectionPeersIpv4Vrf[i].Vrf = types.StringNull()
		}
		if value := r.Get("source"); value.Exists() && !data.SxpConnectionPeersIpv4Vrf[i].SourceIp.IsNull() {
			data.SxpConnectionPeersIpv4Vrf[i].SourceIp = types.StringValue(value.String())
		} else {
			data.SxpConnectionPeersIpv4Vrf[i].SourceIp = types.StringNull()
		}
		if value := r.Get("mode"); value.Exists() && !data.SxpConnectionPeersIpv4Vrf[i].ConnectionMode.IsNull() {
			data.SxpConnectionPeersIpv4Vrf[i].ConnectionMode = types.StringValue(value.String())
		} else {
			data.SxpConnectionPeersIpv4Vrf[i].ConnectionMode = types.StringNull()
		}
		if value := r.Get("option"); value.Exists() && !data.SxpConnectionPeersIpv4Vrf[i].Option.IsNull() {
			data.SxpConnectionPeersIpv4Vrf[i].Option = types.StringValue(value.String())
		} else {
			data.SxpConnectionPeersIpv4Vrf[i].Option = types.StringNull()
		}
		if value := r.Get("hold-time"); value.Exists() && !data.SxpConnectionPeersIpv4Vrf[i].HoldTime.IsNull() {
			data.SxpConnectionPeersIpv4Vrf[i].HoldTime = types.Int64Value(value.Int())
		} else {
			data.SxpConnectionPeersIpv4Vrf[i].HoldTime = types.Int64Null()
		}
		if value := r.Get("max-time"); value.Exists() && !data.SxpConnectionPeersIpv4Vrf[i].MaxTime.IsNull() {
			data.SxpConnectionPeersIpv4Vrf[i].MaxTime = types.Int64Value(value.Int())
		} else {
			data.SxpConnectionPeersIpv4Vrf[i].MaxTime = types.Int64Null()
		}
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.speaker.hold-time"); value.Exists() && !data.SxpSpeakerHoldTime.IsNull() {
		data.SxpSpeakerHoldTime = types.Int64Value(value.Int())
	} else {
		data.SxpSpeakerHoldTime = types.Int64Null()
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.listener.hold-time.min-time"); value.Exists() && !data.SxpListenerHoldMinTime.IsNull() {
		data.SxpListenerHoldMinTime = types.Int64Value(value.Int())
	} else {
		data.SxpListenerHoldMinTime = types.Int64Null()
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.listener.hold-time.max-time"); value.Exists() && !data.SxpListenerHoldMaxTime.IsNull() {
		data.SxpListenerHoldMaxTime = types.Int64Value(value.Int())
	} else {
		data.SxpListenerHoldMaxTime = types.Int64Null()
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:role-based.enforcement-only.enforcement"); !data.RoleBasedEnforcement.IsNull() {
		if value.Exists() {
			data.RoleBasedEnforcement = types.BoolValue(true)
		} else {
			data.RoleBasedEnforcement = types.BoolValue(false)
		}
	} else {
		data.RoleBasedEnforcement = types.BoolNull()
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:role-based.enforcement.logging-interval"); value.Exists() && !data.RoleBasedEnforcementLoggingInterval.IsNull() {
		data.RoleBasedEnforcementLoggingInterval = types.Int64Value(value.Int())
	} else {
		data.RoleBasedEnforcementLoggingInterval = types.Int64Null()
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:role-based.enforcement.vlan-lists"); value.Exists() && !data.RoleBasedEnforcementVlanLists.IsNull() {
		data.RoleBasedEnforcementVlanLists = helpers.GetInt64List(value.Array())
	} else {
		data.RoleBasedEnforcementVlanLists = types.ListNull(types.Int64Type)
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:role-based.permissions.default.ACL-name-new"); value.Exists() && !data.RoleBasedPermissionsDefaultAclName.IsNull() {
		data.RoleBasedPermissionsDefaultAclName = helpers.GetStringList(value.Array())
	} else {
		data.RoleBasedPermissionsDefaultAclName = types.ListNull(types.StringType)
	}
}

// End of section. //template:end updateFromBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBody

func (data *CTS) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:authorization.list"); value.Exists() {
		data.AuthorizationList = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sgt"); value.Exists() {
		data.Sgt = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.sxp-def-enable"); value.Exists() {
		data.SxpEnable = types.BoolValue(value.Bool())
	} else {
		data.SxpEnable = types.BoolNull()
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.default.password.type"); value.Exists() {
		data.SxpDefaultPasswordType = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.default.password.secret"); value.Exists() {
		data.SxpDefaultPassword = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.retry.period"); value.Exists() {
		data.SxpRetryPeriod = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-no-vrf"); value.Exists() {
		data.SxpConnectionPeersIpv4 = make([]CTSSxpConnectionPeersIpv4, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := CTSSxpConnectionPeersIpv4{}
			if cValue := v.Get("ipv4"); cValue.Exists() {
				item.Ip = types.StringValue(cValue.String())
			}
			if cValue := v.Get("source"); cValue.Exists() {
				item.SourceIp = types.StringValue(cValue.String())
			}
			if cValue := v.Get("password"); cValue.Exists() {
				item.Password = types.StringValue(cValue.String())
			}
			if cValue := v.Get("mode"); cValue.Exists() {
				item.ConnectionMode = types.StringValue(cValue.String())
			}
			if cValue := v.Get("option"); cValue.Exists() {
				item.Option = types.StringValue(cValue.String())
			}
			if cValue := v.Get("hold-time"); cValue.Exists() {
				item.HoldTime = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("max-time"); cValue.Exists() {
				item.MaxTime = types.Int64Value(cValue.Int())
			}
			data.SxpConnectionPeersIpv4 = append(data.SxpConnectionPeersIpv4, item)
			return true
		})
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-with-vrf"); value.Exists() {
		data.SxpConnectionPeersIpv4Vrf = make([]CTSSxpConnectionPeersIpv4Vrf, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := CTSSxpConnectionPeersIpv4Vrf{}
			if cValue := v.Get("ipv4"); cValue.Exists() {
				item.Ip = types.StringValue(cValue.String())
			}
			if cValue := v.Get("vrf"); cValue.Exists() {
				item.Vrf = types.StringValue(cValue.String())
			}
			if cValue := v.Get("source"); cValue.Exists() {
				item.SourceIp = types.StringValue(cValue.String())
			}
			if cValue := v.Get("password"); cValue.Exists() {
				item.Password = types.StringValue(cValue.String())
			}
			if cValue := v.Get("mode"); cValue.Exists() {
				item.ConnectionMode = types.StringValue(cValue.String())
			}
			if cValue := v.Get("option"); cValue.Exists() {
				item.Option = types.StringValue(cValue.String())
			}
			if cValue := v.Get("hold-time"); cValue.Exists() {
				item.HoldTime = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("max-time"); cValue.Exists() {
				item.MaxTime = types.Int64Value(cValue.Int())
			}
			data.SxpConnectionPeersIpv4Vrf = append(data.SxpConnectionPeersIpv4Vrf, item)
			return true
		})
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.speaker.hold-time"); value.Exists() {
		data.SxpSpeakerHoldTime = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.listener.hold-time.min-time"); value.Exists() {
		data.SxpListenerHoldMinTime = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.listener.hold-time.max-time"); value.Exists() {
		data.SxpListenerHoldMaxTime = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:role-based.enforcement-only.enforcement"); value.Exists() {
		data.RoleBasedEnforcement = types.BoolValue(true)
	} else {
		data.RoleBasedEnforcement = types.BoolValue(false)
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:role-based.enforcement.logging-interval"); value.Exists() {
		data.RoleBasedEnforcementLoggingInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:role-based.enforcement.vlan-lists"); value.Exists() {
		data.RoleBasedEnforcementVlanLists = helpers.GetInt64List(value.Array())
	} else {
		data.RoleBasedEnforcementVlanLists = types.ListNull(types.Int64Type)
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:role-based.permissions.default.ACL-name-new"); value.Exists() {
		data.RoleBasedPermissionsDefaultAclName = helpers.GetStringList(value.Array())
	} else {
		data.RoleBasedPermissionsDefaultAclName = types.ListNull(types.StringType)
	}
}

// End of section. //template:end fromBody

// Section below is generated&owned by "gen/generator.go". //template:begin fromBodyData

func (data *CTSData) fromBody(ctx context.Context, res gjson.Result) {
	prefix := helpers.LastElement(data.getPath()) + "."
	if res.Get(helpers.LastElement(data.getPath())).IsArray() {
		prefix += "0."
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:authorization.list"); value.Exists() {
		data.AuthorizationList = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sgt"); value.Exists() {
		data.Sgt = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.sxp-def-enable"); value.Exists() {
		data.SxpEnable = types.BoolValue(value.Bool())
	} else {
		data.SxpEnable = types.BoolNull()
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.default.password.type"); value.Exists() {
		data.SxpDefaultPasswordType = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.default.password.secret"); value.Exists() {
		data.SxpDefaultPassword = types.StringValue(value.String())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.retry.period"); value.Exists() {
		data.SxpRetryPeriod = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-no-vrf"); value.Exists() {
		data.SxpConnectionPeersIpv4 = make([]CTSSxpConnectionPeersIpv4, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := CTSSxpConnectionPeersIpv4{}
			if cValue := v.Get("ipv4"); cValue.Exists() {
				item.Ip = types.StringValue(cValue.String())
			}
			if cValue := v.Get("source"); cValue.Exists() {
				item.SourceIp = types.StringValue(cValue.String())
			}
			if cValue := v.Get("password"); cValue.Exists() {
				item.Password = types.StringValue(cValue.String())
			}
			if cValue := v.Get("mode"); cValue.Exists() {
				item.ConnectionMode = types.StringValue(cValue.String())
			}
			if cValue := v.Get("option"); cValue.Exists() {
				item.Option = types.StringValue(cValue.String())
			}
			if cValue := v.Get("hold-time"); cValue.Exists() {
				item.HoldTime = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("max-time"); cValue.Exists() {
				item.MaxTime = types.Int64Value(cValue.Int())
			}
			data.SxpConnectionPeersIpv4 = append(data.SxpConnectionPeersIpv4, item)
			return true
		})
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.connection.peer.ipv4-with-vrf"); value.Exists() {
		data.SxpConnectionPeersIpv4Vrf = make([]CTSSxpConnectionPeersIpv4Vrf, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := CTSSxpConnectionPeersIpv4Vrf{}
			if cValue := v.Get("ipv4"); cValue.Exists() {
				item.Ip = types.StringValue(cValue.String())
			}
			if cValue := v.Get("vrf"); cValue.Exists() {
				item.Vrf = types.StringValue(cValue.String())
			}
			if cValue := v.Get("source"); cValue.Exists() {
				item.SourceIp = types.StringValue(cValue.String())
			}
			if cValue := v.Get("password"); cValue.Exists() {
				item.Password = types.StringValue(cValue.String())
			}
			if cValue := v.Get("mode"); cValue.Exists() {
				item.ConnectionMode = types.StringValue(cValue.String())
			}
			if cValue := v.Get("option"); cValue.Exists() {
				item.Option = types.StringValue(cValue.String())
			}
			if cValue := v.Get("hold-time"); cValue.Exists() {
				item.HoldTime = types.Int64Value(cValue.Int())
			}
			if cValue := v.Get("max-time"); cValue.Exists() {
				item.MaxTime = types.Int64Value(cValue.Int())
			}
			data.SxpConnectionPeersIpv4Vrf = append(data.SxpConnectionPeersIpv4Vrf, item)
			return true
		})
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.speaker.hold-time"); value.Exists() {
		data.SxpSpeakerHoldTime = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.listener.hold-time.min-time"); value.Exists() {
		data.SxpListenerHoldMinTime = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:sxp.listener.hold-time.max-time"); value.Exists() {
		data.SxpListenerHoldMaxTime = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:role-based.enforcement-only.enforcement"); value.Exists() {
		data.RoleBasedEnforcement = types.BoolValue(true)
	} else {
		data.RoleBasedEnforcement = types.BoolValue(false)
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:role-based.enforcement.logging-interval"); value.Exists() {
		data.RoleBasedEnforcementLoggingInterval = types.Int64Value(value.Int())
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:role-based.enforcement.vlan-lists"); value.Exists() {
		data.RoleBasedEnforcementVlanLists = helpers.GetInt64List(value.Array())
	} else {
		data.RoleBasedEnforcementVlanLists = types.ListNull(types.Int64Type)
	}
	if value := res.Get(prefix + "Cisco-IOS-XE-cts:role-based.permissions.default.ACL-name-new"); value.Exists() {
		data.RoleBasedPermissionsDefaultAclName = helpers.GetStringList(value.Array())
	} else {
		data.RoleBasedPermissionsDefaultAclName = types.ListNull(types.StringType)
	}
}

// End of section. //template:end fromBodyData

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletedItems

func (data *CTS) getDeletedItems(ctx context.Context, state CTS) []string {
	deletedItems := make([]string, 0)
	if !state.RoleBasedPermissionsDefaultAclName.IsNull() {
		if data.RoleBasedPermissionsDefaultAclName.IsNull() {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:role-based/permissions/default/ACL-name-new", state.getPath()))
		} else {
			var dataValues, stateValues []string
			data.RoleBasedPermissionsDefaultAclName.ElementsAs(ctx, &dataValues, false)
			state.RoleBasedPermissionsDefaultAclName.ElementsAs(ctx, &stateValues, false)
			for _, v := range stateValues {
				found := false
				for _, vv := range dataValues {
					if v == vv {
						found = true
						break
					}
				}
				if !found {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:role-based/permissions/default/ACL-name-new=%v", state.getPath(), v))
				}
			}
		}
	}
	if !state.RoleBasedEnforcementVlanLists.IsNull() {
		if data.RoleBasedEnforcementVlanLists.IsNull() {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:role-based/enforcement/vlan-lists", state.getPath()))
		} else {
			var dataValues, stateValues []int
			data.RoleBasedEnforcementVlanLists.ElementsAs(ctx, &dataValues, false)
			state.RoleBasedEnforcementVlanLists.ElementsAs(ctx, &stateValues, false)
			for _, v := range stateValues {
				found := false
				for _, vv := range dataValues {
					if v == vv {
						found = true
						break
					}
				}
				if !found {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:role-based/enforcement/vlan-lists=%v", state.getPath(), v))
				}
			}
		}
	}
	if !state.RoleBasedEnforcementLoggingInterval.IsNull() && data.RoleBasedEnforcementLoggingInterval.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:role-based/enforcement/logging-interval", state.getPath()))
	}
	if !state.RoleBasedEnforcement.IsNull() && data.RoleBasedEnforcement.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:role-based/enforcement-only/enforcement", state.getPath()))
	}
	if !state.SxpListenerHoldMaxTime.IsNull() && data.SxpListenerHoldMaxTime.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/listener/hold-time/max-time", state.getPath()))
	}
	if !state.SxpListenerHoldMinTime.IsNull() && data.SxpListenerHoldMinTime.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/listener/hold-time/min-time", state.getPath()))
	}
	if !state.SxpSpeakerHoldTime.IsNull() && data.SxpSpeakerHoldTime.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/speaker/hold-time", state.getPath()))
	}
	for i := range state.SxpConnectionPeersIpv4Vrf {
		stateKeyValues := [...]string{state.SxpConnectionPeersIpv4Vrf[i].Ip.ValueString(), state.SxpConnectionPeersIpv4Vrf[i].Vrf.ValueString()}

		emptyKeys := true
		if !reflect.ValueOf(state.SxpConnectionPeersIpv4Vrf[i].Ip.ValueString()).IsZero() {
			emptyKeys = false
		}
		if !reflect.ValueOf(state.SxpConnectionPeersIpv4Vrf[i].Vrf.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.SxpConnectionPeersIpv4Vrf {
			found = true
			if state.SxpConnectionPeersIpv4Vrf[i].Ip.ValueString() != data.SxpConnectionPeersIpv4Vrf[j].Ip.ValueString() {
				found = false
			}
			if state.SxpConnectionPeersIpv4Vrf[i].Vrf.ValueString() != data.SxpConnectionPeersIpv4Vrf[j].Vrf.ValueString() {
				found = false
			}
			if found {
				if !state.SxpConnectionPeersIpv4Vrf[i].MaxTime.IsNull() && data.SxpConnectionPeersIpv4Vrf[j].MaxTime.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-with-vrf=%v/max-time", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.SxpConnectionPeersIpv4Vrf[i].HoldTime.IsNull() && data.SxpConnectionPeersIpv4Vrf[j].HoldTime.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-with-vrf=%v/hold-time", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.SxpConnectionPeersIpv4Vrf[i].Option.IsNull() && data.SxpConnectionPeersIpv4Vrf[j].Option.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-with-vrf=%v/option", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.SxpConnectionPeersIpv4Vrf[i].ConnectionMode.IsNull() && data.SxpConnectionPeersIpv4Vrf[j].ConnectionMode.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-with-vrf=%v/mode", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.SxpConnectionPeersIpv4Vrf[i].Password.IsNull() && data.SxpConnectionPeersIpv4Vrf[j].Password.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-with-vrf=%v/password", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.SxpConnectionPeersIpv4Vrf[i].SourceIp.IsNull() && data.SxpConnectionPeersIpv4Vrf[j].SourceIp.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-with-vrf=%v/source", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-with-vrf=%v", state.getPath(), strings.Join(stateKeyValues[:], ",")))
		}
	}
	for i := range state.SxpConnectionPeersIpv4 {
		stateKeyValues := [...]string{state.SxpConnectionPeersIpv4[i].Ip.ValueString()}

		emptyKeys := true
		if !reflect.ValueOf(state.SxpConnectionPeersIpv4[i].Ip.ValueString()).IsZero() {
			emptyKeys = false
		}
		if emptyKeys {
			continue
		}

		found := false
		for j := range data.SxpConnectionPeersIpv4 {
			found = true
			if state.SxpConnectionPeersIpv4[i].Ip.ValueString() != data.SxpConnectionPeersIpv4[j].Ip.ValueString() {
				found = false
			}
			if found {
				if !state.SxpConnectionPeersIpv4[i].MaxTime.IsNull() && data.SxpConnectionPeersIpv4[j].MaxTime.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-no-vrf=%v/max-time", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.SxpConnectionPeersIpv4[i].HoldTime.IsNull() && data.SxpConnectionPeersIpv4[j].HoldTime.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-no-vrf=%v/hold-time", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.SxpConnectionPeersIpv4[i].Option.IsNull() && data.SxpConnectionPeersIpv4[j].Option.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-no-vrf=%v/option", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.SxpConnectionPeersIpv4[i].ConnectionMode.IsNull() && data.SxpConnectionPeersIpv4[j].ConnectionMode.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-no-vrf=%v/mode", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.SxpConnectionPeersIpv4[i].Password.IsNull() && data.SxpConnectionPeersIpv4[j].Password.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-no-vrf=%v/password", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				if !state.SxpConnectionPeersIpv4[i].SourceIp.IsNull() && data.SxpConnectionPeersIpv4[j].SourceIp.IsNull() {
					deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-no-vrf=%v/source", state.getPath(), strings.Join(stateKeyValues[:], ",")))
				}
				break
			}
		}
		if !found {
			deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-no-vrf=%v", state.getPath(), strings.Join(stateKeyValues[:], ",")))
		}
	}
	if !state.SxpRetryPeriod.IsNull() && data.SxpRetryPeriod.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/retry/period", state.getPath()))
	}
	if !state.SxpDefaultPassword.IsNull() && data.SxpDefaultPassword.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/default/password/secret", state.getPath()))
	}
	if !state.SxpDefaultPasswordType.IsNull() && data.SxpDefaultPasswordType.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/default/password/type", state.getPath()))
	}
	if !state.SxpEnable.IsNull() && data.SxpEnable.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/sxp-def-enable", state.getPath()))
	}
	if !state.Sgt.IsNull() && data.Sgt.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sgt", state.getPath()))
	}
	if !state.AuthorizationList.IsNull() && data.AuthorizationList.IsNull() {
		deletedItems = append(deletedItems, fmt.Sprintf("%v/Cisco-IOS-XE-cts:authorization/list", state.getPath()))
	}

	return deletedItems
}

// End of section. //template:end getDeletedItems

// Section below is generated&owned by "gen/generator.go". //template:begin getEmptyLeafsDelete

func (data *CTS) getEmptyLeafsDelete(ctx context.Context) []string {
	emptyLeafsDelete := make([]string, 0)
	if !data.RoleBasedEnforcement.IsNull() && !data.RoleBasedEnforcement.ValueBool() {
		emptyLeafsDelete = append(emptyLeafsDelete, fmt.Sprintf("%v/Cisco-IOS-XE-cts:role-based/enforcement-only/enforcement", data.getPath()))
	}

	return emptyLeafsDelete
}

// End of section. //template:end getEmptyLeafsDelete

// Section below is generated&owned by "gen/generator.go". //template:begin getDeletePaths

func (data *CTS) getDeletePaths(ctx context.Context) []string {
	var deletePaths []string
	if !data.RoleBasedPermissionsDefaultAclName.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:role-based/permissions/default/ACL-name-new", data.getPath()))
	}
	if !data.RoleBasedEnforcementVlanLists.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:role-based/enforcement/vlan-lists", data.getPath()))
	}
	if !data.RoleBasedEnforcementLoggingInterval.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:role-based/enforcement/logging-interval", data.getPath()))
	}
	if !data.RoleBasedEnforcement.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:role-based/enforcement-only/enforcement", data.getPath()))
	}
	if !data.SxpListenerHoldMaxTime.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/listener/hold-time/max-time", data.getPath()))
	}
	if !data.SxpListenerHoldMinTime.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/listener/hold-time/min-time", data.getPath()))
	}
	if !data.SxpSpeakerHoldTime.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/speaker/hold-time", data.getPath()))
	}
	for i := range data.SxpConnectionPeersIpv4Vrf {
		keyValues := [...]string{data.SxpConnectionPeersIpv4Vrf[i].Ip.ValueString(), data.SxpConnectionPeersIpv4Vrf[i].Vrf.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-with-vrf=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	for i := range data.SxpConnectionPeersIpv4 {
		keyValues := [...]string{data.SxpConnectionPeersIpv4[i].Ip.ValueString()}

		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/connection/peer/ipv4-no-vrf=%v", data.getPath(), strings.Join(keyValues[:], ",")))
	}
	if !data.SxpRetryPeriod.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/retry/period", data.getPath()))
	}
	if !data.SxpDefaultPassword.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/default/password/secret", data.getPath()))
	}
	if !data.SxpDefaultPasswordType.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/default/password/type", data.getPath()))
	}
	if !data.SxpEnable.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sxp/sxp-def-enable", data.getPath()))
	}
	if !data.Sgt.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:sgt", data.getPath()))
	}
	if !data.AuthorizationList.IsNull() {
		deletePaths = append(deletePaths, fmt.Sprintf("%v/Cisco-IOS-XE-cts:authorization/list", data.getPath()))
	}

	return deletePaths
}

// End of section. //template:end getDeletePaths
