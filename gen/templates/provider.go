//go:build ignore
// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

// Section below is generated&owned by "gen/generator.go". //template:begin provider
import (
	"context"
	"fmt"
	"net"
	"os"
	"slices"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/CiscoDevNet/terraform-provider-iosxe/internal/provider/helpers"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/provider"
	"github.com/hashicorp/terraform-plugin-framework/provider/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/netascode/go-netconf"
	"github.com/netascode/go-restconf"
)

// parseHostPort extracts hostname and port from a host string.
// If the host contains a port (e.g., "host:2306"), it returns the hostname and port separately.
// If no port is specified, it returns the original host and the defaultPort.
// This is needed because go-netconf requires the port to be set via the Port() option,
// not embedded in the host string.
func parseHostPort(host string, defaultPort int) (string, int) {
	// Try to split host:port
	h, p, err := net.SplitHostPort(host)
	if err != nil {
		// No port specified or invalid format, return as-is with default port
		return host, defaultPort
	}
	// Parse the port
	port, err := strconv.Atoi(p)
	if err != nil {
		// Invalid port, return original host with default port
		return host, defaultPort
	}
	return h, port
}

var _ provider.Provider = &IosxeProvider{}
var _ provider.ProviderWithActions = &IosxeProvider{}

const (
	YangPatch = false
)

// IosxeProvider defines the provider implementation.
type IosxeProvider struct {
	// version is set to the provider version on release, "dev" when the
	// provider is built and ran locally, and "test" when running acceptance
	// testing.
	version string
}

// IosxeProviderModel describes the provider data model.
type IosxeProviderModel struct {
	Username           types.String               `tfsdk:"username"`
	Password           types.String               `tfsdk:"password"`
	URL                types.String               `tfsdk:"url"`
	Host               types.String               `tfsdk:"host"`
	Insecure           types.Bool                 `tfsdk:"insecure"`
	Protocol           types.String               `tfsdk:"protocol"`
	Retries            types.Int64                `tfsdk:"retries"`
	LockReleaseTimeout types.Int64                `tfsdk:"lock_release_timeout"`
	ReuseConnection    types.Bool                 `tfsdk:"reuse_connection"`
	AutoCommit         types.Bool                 `tfsdk:"auto_commit"`
	SelectedDevices    types.List                 `tfsdk:"selected_devices"`
	Devices            []IosxeProviderModelDevice `tfsdk:"devices"`
}

type IosxeProviderModelDevice struct {
	Name     types.String `tfsdk:"name"`
	URL      types.String `tfsdk:"url"`
	Host     types.String `tfsdk:"host"`
	Protocol types.String `tfsdk:"protocol"`
	Managed  types.Bool   `tfsdk:"managed"`
}

// IosxeProviderData describes the data maintained by the provider.
type IosxeProviderData struct {
	Devices map[string]*IosxeProviderDataDevice
}

type IosxeProviderDataDevice struct {
	RestconfClient  *restconf.Client
	NetconfClient   *netconf.Client
	Protocol        string
	ReuseConnection bool
	AutoCommit      bool
	Managed         bool
	NetconfOpMutex  sync.Mutex // Serializes NETCONF operations (all ops when reuse disabled, writes only when reuse enabled)
}

func (p *IosxeProvider) Metadata(ctx context.Context, req provider.MetadataRequest, resp *provider.MetadataResponse) {
	resp.TypeName = "iosxe"
	resp.Version = p.version
}

func (p *IosxeProvider) Schema(ctx context.Context, req provider.SchemaRequest, resp *provider.SchemaResponse) {
	resp.Schema = schema.Schema{
		Attributes: map[string]schema.Attribute{
			"username": schema.StringAttribute{
				MarkdownDescription: "Username for the IOS-XE device. This can also be set as the IOSXE_USERNAME environment variable.",
				Optional:            true,
			},
			"password": schema.StringAttribute{
				MarkdownDescription: "Password for the IOS-XE device. This can also be set as the IOSXE_PASSWORD environment variable.",
				Optional:            true,
				Sensitive:           true,
			},
			"url": schema.StringAttribute{
				MarkdownDescription: "URL of the Cisco IOS-XE device for RESTCONF protocol. Optionally a port can be added with `:12345`. The default port is `443`. This can also be set as the IOSXE_URL environment variable. **Deprecated: Use `host` instead for protocol-agnostic configuration.**",
				Optional:            true,
				DeprecationMessage:  "Use 'host' attribute instead for protocol-agnostic configuration",
			},
			"host": schema.StringAttribute{
				MarkdownDescription: "Hostname or IP address of the Cisco IOS-XE device. Optionally a port can be added with `:port`. Default port is `443` for RESTCONF and `830` for NETCONF. This can also be set as the IOSXE_HOST environment variable.",
				Optional:            true,
			},
			"insecure": schema.BoolAttribute{
				MarkdownDescription: "Allow insecure HTTPS client. This can also be set as the IOSXE_INSECURE environment variable. Defaults to `true`.",
				Optional:            true,
			},
			"protocol": schema.StringAttribute{
				MarkdownDescription: "Protocol to use for device communication. Either `restconf` (HTTPS) or `netconf` (SSH). This can also be set as the IOSXE_PROTOCOL environment variable. Defaults to `netconf`.",
				Optional:            true,
				Validators: []validator.String{
					stringvalidator.OneOf("restconf", "netconf"),
				},
			},
			"retries": schema.Int64Attribute{
				MarkdownDescription: "Number of retries for REST API calls. This can also be set as the IOSXE_RETRIES environment variable. Defaults to `10` for RESTCONF and `3` for NETCONF.",
				Optional:            true,
				Validators: []validator.Int64{
					int64validator.Between(0, 99),
				},
			},
			"lock_release_timeout": schema.Int64Attribute{
				MarkdownDescription: "Number of seconds to wait for the device database lock to be released. This can also be set as the IOSXE_LOCK_RELEASE_TIMEOUT environment variable. Defaults to `120`.",
				Optional:            true,
				Validators: []validator.Int64{
					int64validator.Between(0, 600),
				},
			},
			"reuse_connection": schema.BoolAttribute{
				MarkdownDescription: "Keep NETCONF connections open between operations for better performance. **Required when auto_commit=false** - Manual commit mode requires persistent connections to maintain staged candidate configuration changes. When disabled, connections are closed and reopened for each operation. Only applies to NETCONF protocol. This can also be set as the IOSXE_REUSE_CONNECTION environment variable. Defaults to `true`.",
				Optional:            true,
			},
			"auto_commit": schema.BoolAttribute{
				MarkdownDescription: "Automatically commit configuration changes after each resource operation. When `true` (default), each resource commits its changes immediately. When `false`, changes are left in the candidate datastore and must be explicitly committed using the `iosxe_commit` resource. **Requires reuse_connection=true when disabled**. Only applies to NETCONF protocol with candidate datastore support. This can also be set as the IOSXE_AUTO_COMMIT environment variable. Defaults to `true`.",
				Optional:            true,
			},
			"selected_devices": schema.ListAttribute{
				MarkdownDescription: "This can be used to select a list of devices to manage from the `devices` list. Selected devices will be managed while other devices will be skipped and their state will be frozen. This can be used to deploy changes to a subset of devices. Defaults to all devices.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"devices": schema.ListNestedAttribute{
				MarkdownDescription: "This can be used to manage a list of devices from a single provider. All devices must use the same credentials. Each resource and data source has an optional attribute named `device`, which can then select a device by its name from this list.",
				Optional:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							MarkdownDescription: "Device name.",
							Required:            true,
						},
						"url": schema.StringAttribute{
							MarkdownDescription: "URL of the Cisco IOS-XE device for RESTCONF protocol. **Deprecated: Use `host` instead.**",
							Optional:            true,
							DeprecationMessage:  "Use 'host' attribute instead",
						},
						"host": schema.StringAttribute{
							MarkdownDescription: "Hostname or IP address of the Cisco IOS-XE device. Optionally a port can be added with `:port`.",
							Optional:            true,
						},
						"protocol": schema.StringAttribute{
							MarkdownDescription: "Protocol to use for this device. Either `restconf` (HTTPS) or `netconf` (SSH). Overrides the global protocol setting if specified.",
							Optional:            true,
							Validators: []validator.String{
								stringvalidator.OneOf("restconf", "netconf"),
							},
						},
						"managed": schema.BoolAttribute{
							MarkdownDescription: "Enable or disable device management. This can be used to temporarily skip a device due to maintainance for example. Defaults to `true`.",
							Optional:            true,
						},
					},
				},
			},
		},
	}
}

func (p *IosxeProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) {
	// Retrieve provider data from configuration
	var config IosxeProviderModel
	diags := req.Config.Get(ctx, &config)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// User must provide a username to the provider
	var username string
	if config.Username.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as username",
		)
		return
	}

	if config.Username.IsNull() {
		username = os.Getenv("IOSXE_USERNAME")
	} else {
		username = config.Username.ValueString()
	}

	if username == "" {
		// Error vs warning - empty value must stop execution
		resp.Diagnostics.AddError(
			"Unable to find username",
			"Username cannot be an empty string",
		)
		return
	}

	// User must provide a password to the provider
	var password string
	if config.Password.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as password",
		)
		return
	}

	if config.Password.IsNull() {
		password = os.Getenv("IOSXE_PASSWORD")
	} else {
		password = config.Password.ValueString()
	}

	if password == "" {
		// Error vs warning - empty value must stop execution
		resp.Diagnostics.AddError(
			"Unable to find password",
			"Password cannot be an empty string",
		)
		return
	}

	// Determine protocol
	var protocol string
	if config.Protocol.IsUnknown() {
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as protocol",
		)
		return
	}

	if config.Protocol.IsNull() {
		protocol = os.Getenv("IOSXE_PROTOCOL")
		if protocol == "" {
			protocol = "netconf" // default
		}
	} else {
		protocol = config.Protocol.ValueString()
	}

	// Validate protocol
	if protocol != "restconf" && protocol != "netconf" {
		resp.Diagnostics.AddError(
			"Invalid protocol",
			fmt.Sprintf("Protocol must be 'restconf' or 'netconf', got: %s", protocol),
		)
		return
	}

	// User must provide a host or url to the provider
	var host string
	if config.Host.IsUnknown() && config.URL.IsUnknown() {
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as host or url",
		)
		return
	}

	// Priority: host > url > IOSXE_HOST env > IOSXE_URL env > first device
	if !config.Host.IsNull() {
		host = config.Host.ValueString()
	} else if !config.URL.IsNull() {
		host = config.URL.ValueString()
		// Strip https:// prefix for NETCONF
		if protocol == "netconf" {
			host = strings.TrimPrefix(host, "https://")
			host = strings.TrimPrefix(host, "http://")
		}
	} else {
		host = os.Getenv("IOSXE_HOST")
		if host == "" {
			host = os.Getenv("IOSXE_URL")
			if protocol == "netconf" {
				host = strings.TrimPrefix(host, "https://")
				host = strings.TrimPrefix(host, "http://")
			}
		}
		if host == "" && len(config.Devices) > 0 {
			if !config.Devices[0].Host.IsNull() {
				host = config.Devices[0].Host.ValueString()
			} else {
				host = config.Devices[0].URL.ValueString()
				if protocol == "netconf" {
					host = strings.TrimPrefix(host, "https://")
					host = strings.TrimPrefix(host, "http://")
				}
			}
		}
	}

	if host == "" {
		resp.Diagnostics.AddError(
			"Unable to find host",
			"Host or URL cannot be an empty string",
		)
		return
	}

	var insecure bool
	if config.Insecure.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as insecure",
		)
		return
	}

	if config.Insecure.IsNull() {
		insecureStr := os.Getenv("IOSXE_INSECURE")
		if insecureStr == "" {
			insecure = true
		} else {
			insecure, _ = strconv.ParseBool(insecureStr)
		}
	} else {
		insecure = config.Insecure.ValueBool()
	}

	var lockReleaseTimeout int64
	if config.LockReleaseTimeout.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as lockReleaseTimeout",
		)
		return
	}

	if config.LockReleaseTimeout.IsNull() {
		lockReleaseTimeoutStr := os.Getenv("IOSXE_LOCK_RELEASE_TIMEOUT")
		if lockReleaseTimeoutStr == "" {
			lockReleaseTimeout = 120
		} else {
			lockReleaseTimeout, _ = strconv.ParseInt(lockReleaseTimeoutStr, 0, 64)
		}
	} else {
		lockReleaseTimeout = config.LockReleaseTimeout.ValueInt64()
	}

	var reuseConnection bool
	if config.ReuseConnection.IsUnknown() {
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as reuseConnection",
		)
		return
	}

	if config.ReuseConnection.IsNull() {
		reuseConnectionStr := os.Getenv("IOSXE_REUSE_CONNECTION")
		if reuseConnectionStr == "" {
			reuseConnection = true
		} else {
			reuseConnection, _ = strconv.ParseBool(reuseConnectionStr)
		}
	} else {
		reuseConnection = config.ReuseConnection.ValueBool()
	}

	var autoCommit bool
	if config.AutoCommit.IsUnknown() {
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as autoCommit",
		)
		return
	}

	if config.AutoCommit.IsNull() {
		autoCommitStr := os.Getenv("IOSXE_AUTO_COMMIT")
		if autoCommitStr == "" {
			autoCommit = true
		} else {
			autoCommit, _ = strconv.ParseBool(autoCommitStr)
		}
	} else {
		autoCommit = config.AutoCommit.ValueBool()
	}

	var selectedDevices []string
	if config.SelectedDevices.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as selectedDevices",
		)
		return
	}

	if config.SelectedDevices.IsNull() {
		selectedDevicesStr := os.Getenv("IOSXE_SELECTED_DEVICES")
		if selectedDevicesStr != "" {
			selectedDevices = strings.Split(selectedDevicesStr, ",")
		}
	} else {
		diags = config.SelectedDevices.ElementsAs(ctx, &selectedDevices, false)
		resp.Diagnostics.Append(diags...)
	}

	var retries int64
	if config.Retries.IsUnknown() {
		// Cannot connect to client with an unknown value
		resp.Diagnostics.AddWarning(
			"Unable to create client",
			"Cannot use unknown value as retries",
		)
		return
	}

	if config.Retries.IsNull() {
		retriesStr := os.Getenv("IOSXE_RETRIES")
		if retriesStr == "" {
			if protocol == "restconf" {
				retries = 10
			} else {
				retries = 3
			}
		} else {
			retries, _ = strconv.ParseInt(retriesStr, 0, 64)
		}
	} else {
		retries = config.Retries.ValueInt64()
	}

	// Validate configuration dependencies
	if protocol == "netconf" && !autoCommit && !reuseConnection {
		resp.Diagnostics.AddError(
			"Invalid Configuration",
			"Manual commit mode (auto_commit=false) requires connection reuse (reuse_connection=true). "+
				"Without connection reuse, staged candidate configuration changes would be lost when "+
				"connections close between resource operations. Either set auto_commit=true or reuse_connection=true.",
		)
		return
	}

	data := IosxeProviderData{}
	data.Devices = make(map[string]*IosxeProviderDataDevice)

	// Create default device client based on protocol
	if protocol == "restconf" {
		// For RESTCONF, add https:// prefix if not present
		url := host
		if !strings.HasPrefix(url, "https://") && !strings.HasPrefix(url, "http://") {
			url = "https://" + url
		}
		c, err := restconf.NewClient(url, username, password, insecure, restconf.MaxRetries(int(retries)), restconf.SkipDiscovery("/restconf", true), restconf.LockReleaseTimeout(int(lockReleaseTimeout)))
		if err != nil {
			resp.Diagnostics.AddError(
				"Unable to create RESTCONF client",
				"Unable to create RESTCONF client:\n\n"+err.Error(),
			)
			return
		}
		data.Devices[""] = &IosxeProviderDataDevice{RestconfClient: c, Protocol: "restconf", ReuseConnection: reuseConnection, AutoCommit: autoCommit, Managed: true}
	} else {
		// NETCONF
		// Parse host:port - go-netconf requires port to be set separately via Port() option
		netconfHost, netconfPort := parseHostPort(host, 830)
		logger := helpers.NewTflogAdapter(host)
		opts := []func(*netconf.Client){
			netconf.Username(username),
			netconf.Password(password),
			netconf.MaxRetries(int(retries)),
			netconf.LockReleaseTimeout(time.Duration(lockReleaseTimeout) * time.Second),
			netconf.WithLogger(logger),
		}
		if netconfPort != 830 {
			opts = append(opts, netconf.Port(netconfPort))
		}
		if insecure {
			opts = append(opts, netconf.InsecureSkipHostKeyVerification())
		}
		c, err := netconf.NewClient(netconfHost, opts...)
		if err != nil {
			resp.Diagnostics.AddError(
				"Unable to create NETCONF client",
				"Unable to create NETCONF client:\n\n"+err.Error(),
			)
			return
		}
		data.Devices[""] = &IosxeProviderDataDevice{NetconfClient: c, Protocol: "netconf", ReuseConnection: reuseConnection, AutoCommit: autoCommit, Managed: true}
	}

	for _, device := range config.Devices {
		var managed bool
		if len(selectedDevices) > 0 {
			if slices.Contains(selectedDevices, device.Name.ValueString()) {
				managed = true
			} else {
				managed = false
			}
		} else {
			if device.Managed.IsUnknown() || device.Managed.IsNull() {
				managed = true
			} else {
				managed = device.Managed.ValueBool()
			}
		}

		// Determine device protocol (prefer device-specific over global)
		deviceProtocol := protocol
		if !device.Protocol.IsNull() && !device.Protocol.IsUnknown() {
			deviceProtocol = device.Protocol.ValueString()
		}

		// Determine device host (prefer host over url)
		var deviceHost string
		if !device.Host.IsNull() {
			deviceHost = device.Host.ValueString()
		} else {
			deviceHost = device.URL.ValueString()
			// Strip https:// prefix for NETCONF
			if deviceProtocol == "netconf" {
				deviceHost = strings.TrimPrefix(deviceHost, "https://")
				deviceHost = strings.TrimPrefix(deviceHost, "http://")
			}
		}

		// Create device client based on device-specific protocol
		if deviceProtocol == "restconf" {
			// For RESTCONF, add https:// prefix if not present
			url := deviceHost
			if !strings.HasPrefix(url, "https://") && !strings.HasPrefix(url, "http://") {
				url = "https://" + url
			}
			c, err := restconf.NewClient(url, username, password, insecure, restconf.MaxRetries(int(retries)), restconf.SkipDiscovery("/restconf", true), restconf.LockReleaseTimeout(int(lockReleaseTimeout)))
			if err != nil {
				resp.Diagnostics.AddError(
					"Unable to create RESTCONF client",
					fmt.Sprintf("Unable to create RESTCONF client for device '%s':\n\n%s", device.Name.ValueString(), err.Error()),
				)
				return
			}
			data.Devices[device.Name.ValueString()] = &IosxeProviderDataDevice{RestconfClient: c, Protocol: deviceProtocol, ReuseConnection: reuseConnection, AutoCommit: autoCommit, Managed: managed}
		} else {
			// NETCONF
			// Parse host:port - go-netconf requires port to be set separately via Port() option
			netconfHost, netconfPort := parseHostPort(deviceHost, 830)
			// Use device name as identifier for better log correlation
			deviceID := device.Name.ValueString()
			logger := helpers.NewTflogAdapter(deviceID)
			opts := []func(*netconf.Client){
				netconf.Username(username),
				netconf.Password(password),
				netconf.MaxRetries(int(retries)),
				netconf.LockReleaseTimeout(time.Duration(lockReleaseTimeout) * time.Second),
				netconf.WithLogger(logger),
			}
			if netconfPort != 830 {
				opts = append(opts, netconf.Port(netconfPort))
			}
			if insecure {
				opts = append(opts, netconf.InsecureSkipHostKeyVerification())
			}
			c, err := netconf.NewClient(netconfHost, opts...)
			if err != nil {
				resp.Diagnostics.AddError(
					"Unable to create NETCONF client",
					fmt.Sprintf("Unable to create NETCONF client for device '%s':\n\n%s", device.Name.ValueString(), err.Error()),
				)
				return
			}
			data.Devices[device.Name.ValueString()] = &IosxeProviderDataDevice{NetconfClient: c, Protocol: deviceProtocol, ReuseConnection: reuseConnection, AutoCommit: autoCommit, Managed: managed}
		}
	}

	resp.DataSourceData = &data
	resp.ResourceData = &data
}

func (p *IosxeProvider) Resources(_ context.Context) []func() resource.Resource {
	return []func() resource.Resource{
		NewYangResource,
		NewSaveConfigResource,
		NewCliResource,
		NewCommitResource,
		{{- range .}}
		New{{camelCase .Name}}Resource,
		{{- end}}
	}
}

func (p *IosxeProvider) DataSources(_ context.Context) []func() datasource.DataSource {
	return []func() datasource.DataSource{
		NewYangDataSource,
		{{- range .}}
		New{{camelCase .Name}}DataSource,
		{{- end}}
	}
}

func (p *IosxeProvider) Actions(_ context.Context) []func() action.Action {
	return []func() action.Action{
		NewCommitAction,
		NewSaveConfigAction,
	}
}

func New(version string) func() provider.Provider {
	return func() provider.Provider {
		return &IosxeProvider{
			version: version,
		}
	}
}

// End of section. //template:end provider
